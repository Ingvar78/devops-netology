# Домашнее задание к занятию "6.1. Типы и структура СУБД"

## Введение

Перед выполнением задания вы можете ознакомиться с 
[дополнительными материалами](https://github.com/netology-code/virt-homeworks/tree/master/additional/README.md).

## Задача 1

Архитектор ПО решил проконсультироваться у вас, какой тип БД 
лучше выбрать для хранения определенных данных.

Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:

- Электронные чеки в json виде

    Документо-ориентированные - наиболее подходящий вариант для хранения иерархических структур данных (документов) и обычно реализуемая с помощью подхода NoSQL. В данном случае под документом понимается электронный чек представленный в виде json.

- Склады и автомобильные дороги для логистической компании

    Графовые - Склады представляют собой узлы, автомобильные дороги - ребра представляющие собой отношения между складами.

- Генеалогические деревья

    Иерархические - древовидная структура, записи связаны друг с другом через связи в отношениях родитель-потомок.

- Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации

    Ключ-значение - идентификатор клиента может выступать в виде ключа, значение для аутентификации - значение которое может быть представлено в виде отдельной записи или набора параметров, в том числе и времени жизни токена

- Отношения клиент-покупка для интернет-магазина

    Реляционная - отношение клиент-покупка удобно хранить в виде отдельных таблиц связанных между собой, таблица клиентов-> таблица покупок,заказов

Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

## Задача 2

Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно 
CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если 
(каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию)
А согласно PACELC-теореме, как бы вы классифицировали данные реализации?:

- Данные записываются на все узлы с задержкой до часа (асинхронная запись)

    По классификации CAP - PA - удовлетворяет доступности и разделению, но не удовлетворяет согласованности данных в единицу времени. 
    По классификаиции PACELC это будет PA/EC- удовлетворяет разделению и доступности, фокусируется на скорости ответа и доступности, отводя консистентность на второй план.

- При сетевых сбоях, система может разделиться на 2 раздельных кластера

    PA - удовлетворяет доступности и устойчива к разделению системы, консистентность данных в двух кластерах зависит от реализации и принятых ограничениях и не гарантируется.
    PA/EL - удовлетворяет требованиям высокой доступности при разделении, высокая скорость ответа ставится на второй план

- Система может не прислать корректный ответ или сбросить соединение

    AC - система не устойчива к разделению системы, что и приводит к сбросу и некорректным ответам. на первое место ставится доступность, на второе консистентность данных.
    PC/EC - система, которая стремится к консистентности и при сетевом разделении, и без него, в жертву приносится доступность.

    [Нам мало CAP. Да здравствует PACELC](https://habr.com/ru/company/gaz-is/blog/551986/)


## Задача 3

Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?

Нет, принципы ACID позволяеют проектировать высоконадежные системы, в то время как BASE позволяет проектировать высокопроизводительные системы.
При выборе между ACID и BASE требукется определиться какой результат мы приследуем - высоконадёжные или высокопроизводительные системы на выходе.
ACID требует полной согласованности, производительность не является приоритетным показателем, допускает возможность не получить ответ на запрос, 
BASE может находиться в несогласованном состоянии некоторое время, что позволяет обеспечить высокую доступность, и всегда получить ответ на запросы, однако не гарантирует верность данных в ответе.

Полностью совместить два этих принципа не возможно в рамках одной СУБД, однако можно использовать комбинацию принципов в рамках одной информационной системы, которые будут компенсировать недостатки двух этих подходов и по возможности удовлетворять обоим принципам. 
В качестве примера - использование кластера БД PostgreSQL для хранения данных и Redis для координации очередей фоновых заданий (и некоторых ограниченных атомарных операций)

ACID - требования к СУБД, в обеспечение надежности и предсказуемости ее работы.
- A - atomicity (атомарность) никакая транзакция не будет зафиксирована в БД частично.
- C - consistency (согласованность) каждая успешная транзакция фиксирует только допустимые результаты.
- I - isolation (изоляция) параллельные транзакции не искажают результат друг друга.
- D - durability (стойкость) гарантия применения успешных транзакций, независимо от низкоуровневых проблем.
ACID позволяет проектировать высоконадежные системы.

BASE - принцип, противопоставляющий себя ACID.
- BA - basically availability (базовая доступность) деградация части узлов ведет к деградации части сессий, исключая полную деградацию системы. Система отвечает на любой запрос, но в ответе могут быть неверные данные.
- S - soft state (неустойчивое состояние) уменьшение времени хранения сессий и фиксация обновлений только критичных операций. 
- E - eventually consistent (конечная согласованность) изменение состояния в конечном итоге применится на все системы
BASE позволяет проектировать высокопроизводительные системы.


## Задача 4

Вам дали задачу написать системное решение, основой которого бы послужили:

- фиксация некоторых значений с временем жизни
- реакция на истечение таймаута

Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
Что это за система? Какие минусы выбора данной системы?

Есть решения для организации key-value хранилищ, для решения задачи описанной выше - подходит Redis и Apache Kafka. В свою очередь каждое из решений имеет свои преимущества и недостатки.

Из минусов Redis стоит упомянуть следующее: 
- Если издатель по каким-либо причинам выходит из строя, то он теряет всех своих подписчиков
- Издателю необходимо знать точный адрес всех его подписчиков
- Издатель может перегрузить работой своих подписчиков, если данные публикуются быстрее, чем обрабатываются
- Сообщение удаляется из буфера издателя сразу после публикации, не зависимо от того, какому числу подписчиков оно доставлено и как быстро те сумели обработать это сообщение.
- Все подписчики получат сообщение одновременно. Подписчики сами должны как-то между собой согласовывать порядок обработки одного и того же сообщения.
- Нет встроенного механизма подтверждения успешной обработки сообщения подписчиком. Если подписчик получил сообщение и свалился во время обработки, то издатель об этом не узнает.

Apache Kafka в этом смысле более надёжна, т.к. данные делятся по разделам (partition) и чтобы соблюдать порядок доставки каждый получатель сообщений читает данные ровно из одного раздела.
Однако это может приводить к блокировке очереди в случае, когда получатель по каким-либо причинам обрабатывает сообщения медленнее обычного.
Так же недостатком kafka является сложность управления кластером, требут конфигурирования для этого отдельного сервиса (zookeper). 

И Redis и Kafka позволяют управлять временем жизни сообщений, однако механизмы управления сильно отличаются - в редис мы можем указать TTL для конкретного сообщения, в Kafka - ограничение действует на все сообщения в топике.

---

