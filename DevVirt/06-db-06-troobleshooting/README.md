# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

>CRUD операции - создание (create), чтение (read), обновление (update) и удаление (delete).
[MongoDB CRUD Operations](https://docs.mongodb.com/manual/crud/)

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя


1. Вычислить проблемные запросы в mongo-shell в ответе найти нужный query, для этого необходимо выполнить следующий запрос [db.currentOn()](https://docs.mongodb.com/manual/reference/method/db.currentOp/):

```
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 }
   }
)

```

В ответ будет получен список операций которые выполнялись более 3 минут

```
{
  "inprog": [
       {
	...
         "active" : <boolean>,
         "currentOpTime" : <string>,
         "effectiveUsers" : [
            {
               "user" : <string>,
               "db" : <string>
            }
         ],
         ...
         "opid" : <number>,
         "secs_running" : <NumberLong()>,
       ...
       "command" : <document>,
       ...
   ],
   "fsyncLock": <boolean>,
   "info": <string>,
    "ok": <num>
}
```

Возможно CRUD-операция ожидает завершения блокировки

```
db.currentOp(
   {
     "waitingForLock" : true,
     $or: [
        { "op" : { "$in" : [ "insert", "update", "remove" ] } },
        { "command.findandmodify": { $exists: true } }
    ]
   }
)

```

2. Принудительно удалить подвисшую сессию, определив причину (https://docs.mongodb.com/manual/tutorial/terminate-running-operations/#killop)

```
db.killOp(<opid>)
```
где <opid> - номер зависшей операции


- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

```
1. Использовать метод maxTimeMS() для ограничения времени выполнения операций 
2. Используя Database Profiler, отловить медленные операции.
3. Провести анализ плана выполнения запроса через explain("executionStats"
4. Провести оптимизацию: добавить/скорректировать/удалить индексы, настроить шардинг и т.д.

```

Доп. инф.: [explain](https://docs.atlas.mongodb.com/atlas-search/explain/)


## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?


>Проблема может заключаться в том, что срок действия ключей реплик не истекает, вместо этого они ожидают, истечения срока действия ключей мастеров. 
Когда на мастере истекает срок действия ключа (или он удаляется из-за LRU), он синтезирует команду DEL, которая передается на все реплики. 
В какой-то момент число команд на запись и удаление достигает предела, и новые запросы начинают блокироваться. 
Так же возможной причиной большого количества ключей с истёкшим временем может быть прямое указание времени истечения в unix формате (EXPIREAT) а не TTL ключа в секундах.

 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

>Возможные причины указаны в [статье](https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html):
Объемные запросы на миллионы строк (в нашнем случае выросла БД) - рекомендуется изменение параметра net_read_timeout в сторону увеличения,
Так же на появление данной ошибки может влиять значение параметра connect_timeout - проверить наличие проблемы можно выполнив запрос (SHOW GLOBAL STATUS LIKE 'Aborted_connects').
Размер сообщения/запроса превышает размер буфера max_allowed_packet, в этом случае будет периодически наблюдаться ошибка  ER_NET_PACKET_TOO_LARGE.

Какие пути решения данной проблемы вы можете предложить?

> на стороне сервера: Увеличение следующих значений wait_timeout, max_allowed_packet, net_write_timeout и net_read_timeout. На стороне клиента увеличить wait_timeout, производить pool_pre_ping.
При исчезновении ошибки определить пороговые значения изменённых переменных при которых приложение работает стабильно, т.к. простое увеличение данных параметров может повлиять на работу приложений в целом.


[Решение ошибки через увеличение timeout с default-ных значений](https://stackoverflow.com/questions/49622416/interfaceerror-2013-lost-connection-to-mysql-server-during-query)


## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

>Проблема в нехватке памяти, ядро Linux реализует перераспределение памяти, потребность в памяти для PostgreSQL или другого процесса приводит к тому, что системе не хватает виртуальной памяти и ядро высвобождает его завершая процесс PostgresSQL.

Как бы вы решили данную проблему?

[Настройка на уровне ОС](https://www.postgresql.org/docs/9.3/kernel-resources.html)

[Чрезмерное выделение памяти в Linux](https://postgrespro.ru/docs/postgrespro/9.6/kernel-resources)

>Если памяти не хватает по вине самого PostgresSQL, эту проблему можно решить, изменив конфигурацию сервера. 
В некоторых случаях может помочь уменьшение конфигурационных параметров, связанных с памятью, а именно shared_buffers и work_mem. 
В других случаях проблема может возникать, потому что разрешено слишком много подключений к самому серверу баз данных. Чаще всего в такой ситуации стоит уменьшить число подключений max_connections и организовать внешний пул соединений. 
Один из способов избежать этой проблемы — запускать PostgreSQL на хосте, где другие процессы не будут приводить к нехватке памяти. Исключить влияние других процессов. Если памяти мало - увеличить пространство подкачки операционной системы. 
OOM-Killer вызывается только в случае когда физическая память и пространство подкачки исчерпаны.

---

